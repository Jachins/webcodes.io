#### 例题1
```
    const promise = new Promise((resolve, reject) => {
         console.log(1)
         resolve()
    console.log(2)
    })
    promise.then(() => {
         console.log(3)
    })
console.log(4)

输出结果：  
    1 2 4  3
```
- **解析**：
    - Promise构造函数是**同步执行**，promise.then中的函数是**异步执行**的；

#### 例题2
```
    const first = () => (new Promise((resolve, reject) => {
    console.log(3);
    let p = new Promise((resolve, reject) => {
        console.log(7);
        setTimeout(() => {
            console.log(5);
            resolve(6);
        }, 0)
        resolve(1);
    });
    resolve(2);
    p.then((arg) => {
        console.log(arg);
    });

}));

first().then((arg) => {
    console.log(arg);
});
console.log(4)

输出结果：
    3 7 4 1 2 5
```
- **解析(JS执行机制)：**
    - 第一轮事件循环，先执行宏任务(script,new Promise),输出3，执行P内的new Promise,输出7，发现setTimeout,将回调函数放入下一轮**任务队列(Event Quene)**,p的then放入**微任务队列**，其中first也有then,也放入微任务队列；执行console.log(4)输出4；宏任务执行结束之后，执行微任务，依序输出1，2；第一轮事件循环结束；
    - 第二轮事件循环开始，先执行宏任务里面的回调函数setTimeout,输出5，**resolve(6)不会生效，因为p的promise状态一旦改变就不会发生变化**；

#### 例题3(Promise值穿透)
```
    Promise.resolve('foo')
    .then(Promise.resolve('bar'))
    .then(function(result){
      console.log(result)
    })

    输出结果：
    1
```

- **解析**：.then和.catch的参数期望是函数，传入非函数时会发生值穿透，同时Promise方法通过return传值，**没有return就只是相互独立**的任务

