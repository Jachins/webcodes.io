#### Promise的使用
- Promise是异步编程的一种解决方案；

#### 什么情况下使用promise
- 有**异步操作，使用Promise对这个异步操作进行封装**
- 执行传入的回调函数时，会传入两个参数，resolve和reject，两者本身就是函数；
```
    new Promise((resolve,reject)=>{
        setTimeout(()=>{
            //成功的时候调用resolve(),
            resolve("hello world")
            //失败的时候调用reject()
            reject("err message")
        },1000)
    }).then((data)=>{
        //需要处理的函数，数据,成功的时候调用then()
        console.log(data)
    }).catch((err)=>{
        //失败的时候调用catch
        console.log(err);
    })
```

#### Promise的三种状态
- pending:等待状态，比如正在进行网络请求或者定时器还没到时间；

- fulfill:满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then().

- reject:拒绝状态，当我们主动回调了reject时,就处于该状态，并且会回调.catch().
```
    new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve("fulfill")
            reject("Error Data")
        },1000)
    }).then(data=>{
        console.log(data);
    },err=>{
        console.log(err);
    })
```
- **注意：**then()中可以传入两个函数，第一个是成功时候调用的函数，第二个是失败时候调用的函数。

#### Promise的链式调用
```
    new Promise((resolve,reject)=>{
        setTimeout(()=>{
            resolve('aaa')
        },1000)
    }).then(res=>{
        console.log(res,'第一个');
        return res+'111'(最终简写) === return Promise.resolve(res+'111')(第二种简写)=== return new Promise((resolve)=>{
            resolve(res+'111')(一般写法)
        })
        //当失败的时候调用

        return Promise.reject('err message')
        可简写成：throw 'error message'
    }).then(res=>{
        console.log(res,'第二个');
        return res+'222'  === return Promise.resolve(res+'222')===return new Promise((resolve)=>{
            resolve(res+'222')
        })
    }).then.(res=>{
        console.log(res,'第三个');
    }).catch(err=>{
        console.log(err);
    })//异常时抛出异常信息
```