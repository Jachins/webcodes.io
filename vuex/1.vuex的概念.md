#### vuex是什么？
- 一个专门为Vue.js应用程序开发的**状态管理模式**。

#### vuex的使用步骤
- 1.提取一个公共的store对象，用于保存多个组件共享的状态；
- 2.将store对象放置在new Vue对象中，这样可以保证在所有组件中都可以使用
- 3.在其他组件中使用store对象中保存的状态即可
```
    通过this.$store.state.属性的方式来访问状态；
    通过this.$store.commit('mutation中方法)来修改状态
```
- **注意：** 
    - 通过提交mutation的方式，而不是直接改变store.state.count.
    - 为了方便Vuex可以明确的追踪状态的变化，所以不要直接改变store.state.count的值；

#### Vuex核心概念
- ##### State
    - 单一状态树(Single Source of Truth),单一数据源
    - Vuex中使用单一状态树来管理应用层级的全部状态，将状态信息保存到同一个Store对象中。

- #### Getters
    - 作为参数和传递参数
        - getters默认不能传递参数，但是可以通过让getters返回另一个函数来实现传递参数
        ```
            getter:{
                stuByID:state=>{
                    return function (id){
                        return state.student.find(s=>s.id===id)
                    }
                }
            }
        ```
- #### Mutation
    - vuex的store状态的**更新唯一方式**：提交Mutation
    ```
        increment(){
            this.$store.commit('increment')
        }
        //通过commit提交更新
    ```
    - 还有另一种提交风格，包含了**type**属性的对象
    ```
        this.$store.commit({
            type:'changeCount',
            count:100
        })
    ```
    - Mutation主要包括**两部分**：
        - 1.字符串的**事件类型**(type);
        - 2.一个**回调函数**(handler),该回调函数的第一个参数就是state
        ```
            increment(state){
                state.counter++
            }
            //increment:为事件类型，(state){
                state.counter++
            }为回调函数  
        ```
    - 
- #### Action
    - Action类似于Mutation，一般用来代替Mutation进行异步操作
    ```
        ations:{
            increment(context){
                context.commit('increment')
            }
        }
    ```
    - 其中，**context**是和store对象具有相同方法和属性的对象，可以通过context去进行commit相关的操作，也可以获取context，state等

    - 在Vue组件中，如果调用action中的方法需要调用**dispatch**
    ```
        methods:{
            increment(){
                this.$store.dispatch('increment')
            }
        }
    ```
    - **同样也支持传递payload**
    ```
        methods:{
            increment(){
                this.$store.dispatch('increment',{cCount:5})
            }
        }

        mutations:{
            increment(state,payload){
                state.count += payload.cCount
            }
        },
        actions:{
            increment(context,payload){
                setTimeout(()=>{
                    context.commit('increment',payload)
                },1000)
            }
        }
    ```
    - action返回的**Promise**
    - 可以将异步操作放在一个Promise中，并且在成功或者失败后，调用对应的resolve或reject
    ```
        action：{
            increment(context){
                return new Promise((resolve)=>{
                    settTimeout((=>{
                        context.commit('increment')
                        resolve()
                    },1000))
                })
            }
        }

        methods:{
            increment(){
                this.$store.dispatch('increent').then(res=>{
                    console.log('完成了更新操作');
                })
            }
        }
    ```
- #### Moudule(为什么在Vuex中要使用模块)
    - Vue使用单一状态树，意味着很多操作都要交给vuex来管理
    - 当应用变得复杂的时候，store对象就可能变得相当臃肿
    - 为了解决这个问题,Vuex允许我们将store分割成模板(Module),而每个模块拥有自己的states，mutations，actions，getters

#### 项目结构
- —— index.html
- —— main.js
- —— api
    - —— ...#抽取出的API请求
- —— components
    - —— App.vue
    - —— ...
- —— store
    - —— index.js         # 我们组装模块并导出store的地方
    - —— action.js        # 跟级别的action
    - —— mutation.js      # 根级别的mutation
    - —— modules          
        - —— cart.js      #购物车模块
        - —— products.js  #产品模块