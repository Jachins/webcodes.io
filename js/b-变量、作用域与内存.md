### 1. 原始值和引用值
    - 原始值：最简单的数据；
        保存原始值的变量是**按值**访问的，操作的是我们存储在变量中的实际值；
    - 引用值：有多个值构成的对象
        操作对象时，实际上是对对象的引用，，保存引用值的变量就是**按引用**访问的；
        
### 2. 传递参数
    - 对象是按值传递的，变量有按值访问和按引用访问，但是传参只有按值传递;

### 3. 确定类型
    - typeof用来判断一个变量是什么类型，但是它只对原始值有作用，对引用值用处不大；
    - instanceof操作符用来判断一个对象是什么类型，语法如下：
```
     let result=person instanceof Object;//如果是就返回true,否则就返回false;
```

### 4. 执行上下文与作用域
    ** 执行上下文分为：全局上下文、函数上下文、块级上下文**
    
    - 全局上下文就是最外层的上下文。在浏览器中，全局上下文就是window对象，因此所有通过var定义的全局变量和函数都会变成window对象的属性和方法；
    - 上下文的代码执行的时候，会创建一个变量对象的一个作用域链--决定了各级上下文中的代码访问变量和函数时的顺序。代码正在执行的上下文的变量对象始终位于作用域的最前端。如果上下文是函数，则其活动对象用作变量对象。
    - 代码解析的标识符解析：：通过沿作用域链逐级搜索标识符完成的。
    
### 5. 变量声明
    - 1.使用var的函数作用域声明
        var声明的变量存在变量提升，在声明前打印该变量，输入结果是undefined而不是ReferenceError，可以验证变量已经被提升。
        
    - 2.使用let声明变量
        - 块级作用域由最近的一对{}界定,不存在变量提升;
        - 重复var声明不会报错，但是重复的let声明会报错SyntaxError:某个标识符已经声明过。
        
    - 3.const声明变量，必须声明的同时初始化，且在其声明周期内不能再重新赋值。
        - 声明对象时可以修改对象的属性值；
        
### 6. 垃圾回收
    - 两种方法：标记清理和引用计数；
    
    - 标记清理：当变量进入上下文，比如在函数内部声明一个变量的时候，这个变量会被加上存在于上下文中的标记；而在上下文的变量，逻辑上讲，永远不应该释放他们的内存，因为只要上下文中的代码在运行就会用到他们；当变量离开时，就会被标上离开上下文的标记。
       - 垃圾回收程序运行的时候，标记内存中存储的所有变量，然后会将上下文的所有变量，以及被在   上下文的变量引用的变量的标记去掉。在此之后，在被加上标记的变量就是要删除的了。
    
    - 引用计数：记录每个值被引用的次数。当一个值的引用次数为0的时候，就说明已经访问不到该值，因此就可以安全的回收到内存中。存在问题：两个变量相互引用，永远无法删除(循环引用)；所以舍弃采用标记清理 。