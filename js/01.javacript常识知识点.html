<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .sanjiao {
            width: 0;
            border: 10px solid;
            margin: 2px 19px 12px;
            border-color: red transparent transparent;
            /*   border-color:上 右 下 左
                 border-color:上 左右 下
                 border-color:上下 左右
                  border-color:所有
                 */
            /* */
        }
        
        #id {
            color: blue;
        }
        
        .a,
        .b,
        .c {
            box-sizing: border-box;
            border: 1px solid;
        }
        
        .wrap {
            width: 250px;
        }
        
        .a {
            width: 100px;
            height: 100px;
            float: left;
        }
        
        .b {
            width: 100px;
            height: 50px;
            float: left;
        }
        
        .c {
            width: 100px;
            height: 100px;
            display: inline-block;
        }
    </style>
</head>

<body>
    <div class="wrap">
        <div class="a">a</div>
        <div class="b">b</div>
        <div class="c">c</div>
    </div>
    <span id="id" style="color: red;">Just a text</span>
    <!-- 
        * 1.javascript包括三大部分：
            ! 核心：(ECMAscript)   ！文档对象模型(DOM)    ！浏览器对象模型(BOM)

        * 2.<script>元素：
           ^ 1.推迟执行脚本(defer属性)
            & <script defer src="example.js"></script>
            ~ 对外部脚本才有效，解析完整个页面之后才会执行被延迟的脚本

            ^ 2.异步执行脚本(async属性)
             & <script async src="example.js"></script>
             ~ 表示不需要等待其他脚本，同时也不堵塞文档渲染，不能保证脚本的运行次序；
            
             ^ 3.动态执行脚本()
                & 通过向DOM中动态添加script元素同样可以加载指定的脚本，以异步的方式加载，考虑到并不是所有浏览器都支持async属性，所以统一脚本,同时使用同步的方式加载；
                ~ let script = document.createElement('script');
                ~ script.src ='gibberish.js';
                ~ script.asycn = false;
                ~ document.head.appendChild(script);
        * 3.变量
            & 声明变量有三个关键字：var const let  
            ! var声明和let声明的区别：var声明的是函数作用域，let声明的时块作用域
            ! const声明的是常量，且第一次声明时就必须初始化变量，且该变量的值不可再次修改

            ? 声明风格和最佳实践：不使用var ,const有限，let优先(后两者可以提高代码的质量)
        
        * 4.数据类型
            &原始类型：Undefined、Null、Boolean、Number、String、Symbol、Object；

            ~ typeof操作符：判断一个值的数据类型：undefined、boolean、string、number、object、function、symbol

        * 5.数值转换
            & 有三个函数可以将非数值转换成数值：Number(),parseInt()和parseFloat();
            ~ Number(undefined)==NaN;     Number('')==0;   Number(true)==1;
            ~ 调用valueOf()方法，按照一定的规则返回之前的值，转换结果是NaN,调用toString()方法，再按照转换字符串规则进行转换；

        
     -->
    <script>
        // let time1 = Date.now();
        // let stop = Date.now();
        // console.log(stop - time1);
        // let promise = new Promise((resolve, reject) => {
        //     console.log('111');
        //     setTimeout(() => {
        //         console.log('333');
        //         // resolve('6666');
        //         reject('555');
        //     }, 1000)
        // })
        // promise.then((data) => { //成功的回调
        //     console.log(data, '成功了');
        // }, (error) => { //失败的回调
        //     console.log(error, "失败了");
        // })

        // 定义获取新闻的功能函数
        // function getNews() {
        //     let promise = new Promise((resolve, reject) => {
        //         // 状态：初始化
        //         // 执行异步任务
        //         // 创建xmlHttp实例对象
        //         let xmlHttp = new XMLHttpRequest();
        //         // 绑定监听 readyState
        //         xmlHttp.onreadystatechange = function() {
        //             if (xmlHttp.readyState === 4 && xmlHttp.status === 200) {
        //                 console.log(xmlHttp.responseText);
        //                 // 成功了之后就修改promise的状态，改成成功状态
        //                 resolve();
        //             } else {
        //                 //请求失败
        //                 reject("暂时没有新闻");
        //             }
        //         };
        //         //open 设置请求的方式以及url
        //         xmlHttp.open('GET', url);
        //         // 发送
        //         xmlHttp.send();

        //     })
        // }
        // getNews().then((data) => {
        //     console.log(data);
        // }, (error) => {
        //     console.log(error)
        // })
        let obj = {
            username: 'jachin'
        };
        let obj2 = Object.assign(obj);
        // console.log(obj2.username);
        obj2.username = 'wade';
        console.log(obj2.username);

        let arr = [1, 4, {
            username: 'kobe'
        }];
        let arr1 = [2, 3];
        let arr3 = arr.concat(arr1);
        console.log(arr3);
        let arr4 = arr.slice();
        arr4[2].username = 'xiaojiejie';
        console.log(arr[2].username);

        let arr5 = JSON.parse(JSON.stringify(arr));
        console.log(arr5);
        arr5[2].username = 'shuabi';
        console.log(arr, arr4);

        let ob = {
            username: 'kob',
            age: 33
        };
        for (let i in ob) {
            console.log(i);
        }

        let ar = [1, 3, 'abc'];
        for (let i in ar) {
            console.log(i);
        }
        // 定义检测数据类型的功能函数
        function checkedType(target) {
            return Object.prototype.toString.call(target).slice(8, -1)
        }
        console.log(checkedType(ar));


        // 实现深度克隆-->对象/数组
        function clone(target) {
            // 判断拷贝的数据类型
            // 初始化变量result成为最终克隆的数据
            let result, targetType = checkedType(target);
            if (targetType == 'Object') {
                result = {};

            } else if (targetType == 'Array') {
                result = [];
            } else {
                return target;
            }
            // 遍历目标数据
            for (let i in target) {
                // 获取遍历数据结构的每一项值
                let value = target[i];
                // 判断目标结构里的每一值是否存在对象/数组
                if (checkedType(value) === 'Object' || checkedType(value) === 'Array') {
                    // 则继续遍历获取到的value值
                    result[i] = clone(value);

                } else { //获取到的value值是基本的数据类型或者函数
                    result[i] = value;
                }
            }
            return result;

        }
        let ar1 = [1, 2, {
            username: 'kelong',
            age: 22
        }];
        let ar2 = clone(ar1);
        console.log(ar2);
        ar2[2].username = 'kd';
        console.log(ar1, ar2);


        let rr = [1, 2, 4, 5, 5, 6, 2];
        let rr1 = rr;
        rr = [];
        let set = new Set(rr1);
        for (let i of set) {
            rr.push(i);
        }
        console.log(rr);


        let se = new Set([1, 1, 3, 3, 4, 5, 6]);
        // let result = new Set(set)
        console.log(se);


        let ma = new Map([
            ['aaa', 'username', 24],
            ['bb', 'username']
        ]);
        console.log(ma);
    </script>
    <div id="button0">

    </div>
    <button onclick="test()">排序</button>
    <script>
        function test() {
            var array = [7, 1, 3, 4, 6, 10];
            array.sort = function(a, b) {
                return Math.abs(a - 3) - Math.abs(b - 3)
            };
            // array.sort((a, b) => Math.abs(a - 3) - Math.abs(b - 3));
            // var x = document.getElementById("button0");
            // x.innerHTML = array;
            alert(array);
        }
        // let a = decodeURIComponent('%');
        // console.log(a);
        var a;
        a();

        function a() {
            console.log(a);
        }
        let i = 5;

        function a(i) {
            i *= 2;
        }
        a(i);
        console.log(i)

        let i1 = 0;
        new Array(10).fill(0).forEach(() => {
            i1++;
        });
        console.log(i1);
        let b = 4399 < 0 || typeof(4399 + " ");
        console.log(b);
    </script>


</body>

</html>